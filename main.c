#include <stdio.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>

#pragma region Global Vars

// Constant definitions
#define AUDIO_BASE 0xFF203040
#define KEY_BASE 0xFF200050
#define SWITCH_BASE 0xFF200040
#define TIMER_BASE 0xFF202000
#define PS2_BASE 0xFF200100
#define SIN_IDX 0
#define SQR_IDX 1
#define TRI_IDX 2
#define SAW_IDX 3
#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950288419716939937510
#endif

// Struct definitions
typedef struct audio_s {
    volatile unsigned int CTRL;
    volatile unsigned char RARC, RALC, WSRC, WSLC;
    volatile unsigned int LDATA;
    volatile unsigned int RDATA;
} audio_s;

typedef struct parallel_port {
    volatile unsigned int DR;
    volatile unsigned int DIR;
    volatile unsigned int MASK;
    volatile unsigned int EDGE;
} parallel_port;

typedef struct ps2_port {
    volatile unsigned int DATA;
    volatile unsigned int CTRL;
} ps2_port;

typedef struct timer_s {
    volatile unsigned int STATUS;
    volatile unsigned int CONTROL;
    volatile unsigned int START_LOW;
    volatile unsigned int START_HIGH;
    volatile unsigned int SNAP_SHOT_LOW;
    volatile unsigned int SNAP_SHOT_HIGH;
} timer_s;

typedef struct rectangle {
    int x_base;
    int y_base;
    int width;
    int height;
} rectangle;

typedef struct note_struct {
    bool pressed;
    char name[5];
    uint8_t code;
    char ps2_key;
    float frequency;
    int num_rects;
    rectangle rectangles[2];
} note_struct;

note_struct notes[20] = {
    // White and black key rectangles for each note (starting from C4)
    {false, "C4",  0x15, 'Q',  261.63, 2, {{40, 175, 15, 40}, {40, 215, 20, 20}}},   // C4: White and Black key
    {false, "C#4", 0x1E, '2',  277.18, 1, {{55, 175, 10, 40}, {0, 0, 0, 0}}},           // C#4: Black key
    {false, "D4",  0x1D, 'W',  293.66, 2, {{65, 175, 10, 40}, {60, 215, 20, 20}}},     // D4: White and Black key
    {false, "D#4", 0x26, '3',  311.13, 1, {{75, 175, 10, 40}, {0, 0, 0, 0}}},          // D#4: Black key
    {false, "E4",  0x24, 'E',  329.63, 2, {{85, 175, 15, 40}, {80, 215, 20, 20}}},    // E4: White and Black key
    {false, "F4",  0x2D, 'R',  349.23, 2, {{100, 175, 15, 40}, {100, 215, 20, 20}}},    // F4: White and Black key
    {false, "F#4", 0x2E, '5',  369.99, 1, {{115, 175, 10, 40}, {0, 0, 0, 0}}},          // F#4: Black key
    {false, "G4",  0x2C, 'T',  392.00, 2, {{125, 175, 10, 40}, {120, 215, 20, 20}}},    // G4: White and Black key
    {false, "G#4", 0x36, '6',  415.30, 1, {{135, 175, 10, 40}, {0, 0, 0, 0}}},          // G#4: Black key
    {false, "A4",  0x35, 'Y',  440.00, 2, {{145, 175, 10, 40}, {140, 215, 20, 20}}},    // A4: White and Black key
    {false, "A#4", 0x3D, '7',  466.16, 1, {{155, 175, 10, 40}, {0, 0, 0, 0}}},          // A#4: Black key
    {false, "B4",  0x3C, 'U',  493.88, 2, {{165, 175, 15, 40}, {160, 215, 20, 20}}},    // B4: White and Black key
    {false, "C5",  0x43, 'I',  523.25, 2, {{180, 175, 15, 40}, {180, 215, 20, 20}}},    // C5: White and Black key
    {false, "C#5", 0x46, '9',  554.37, 1, {{195, 175, 10, 40}, {0, 0, 0, 0}}},          // C#5: Black key
    {false, "D5",  0x44, 'O',  587.33, 2, {{205, 175, 10, 40}, {200, 215, 20, 20}}},    // D5: White and Black key
    {false, "D#5", 0x45, '0',  622.25, 1, {{215, 175, 10, 40}, {0, 0, 0, 0}}},          // D#5: Black key
    {false, "E5",  0x4D, 'P',  659.25, 2, {{225, 175, 15, 40}, {220, 215, 20, 20}}},    // E5: White and Black key
    {false, "F5",  0x54, '[',  698.46, 2, {{240, 175, 15, 40}, {240, 215, 20, 20}}},    // F5: White and Black key
    {false, "F#5", 0x55, '=',  739.99, 1, {{255, 175, 10, 40}, {0, 0, 0, 0}}},          // F#5: Black key
    {false, "G5",  0x5B, ']',  783.99, 2, {{265, 175, 15, 40}, {260, 215, 20, 20}}}     // G5: White and Black key
};

double attack_val = 1;
double decay_val = 0.5;
double sustain_val = 1;
double release_val = 0;
bool fast_knob_change = true;

// Function declarations
static void handler(void) __attribute__ ((interrupt ("machine")));
void set_key();
void set_ps2();
void key_isr();
void ps2_isr();
float sine_wave(float phase);
float square_wave(float phase);
float triangle_wave(float phase);
float sawtooth_wave(float phase);

// VGA related functions & settings
volatile int pixel_buffer_start; // global variable
short int Buffer1[240][512]; // 240 rows, 512 (320 + padding) columns (first buffer)
void init_main_screen();
void fill_background();
void draw_line(int x0, int y0, int x1, int y1, short int line_color);
void plot_pixel(int x, int y, short int line_color);
void swap(int* x, int* y);
void wait_for_vsync();
void update_x_y(int* x, int* y, int* last_x, int* last_y, int* last_last_x, int* last_last_y, int* dx, int* dy);
void draw_rect(int x, int y, int width, int height, short int color);
void fill_rect(rectangle rect, short int color);
void fill_rect_noinit(int x_base, int y_base, int width, int height, short int color);
short int rgb_to_16bit(int r, int g, int b);
void draw_main_screen();
void draw_waveform(int x, int y, int width, int height);
void draw_keybd();
void update_keybd(int note_idx);
void draw_adsr();
void draw_wave_selection(int x, int y, int width, int height);
void update_adsr(char changed);

float wave_data_x[140]; // the x-axis for the wave data
float wave_data_y[140]; // the y-axis for the wave data
// int wave_data_plot_x[140]; // we don't need x because it's just a range from 0 to 169
int wave_data_plot_y[140]; // the y-axis for the wave data to be plotted on the screen
void init_wave_data_x();
void update_wave_data_y();

// 0: sine, 1: square, 2: triangle, 3: sawtooth
int current_waves[4] = {0, 1, 0, 0}; // the current wave selected for each note

// sound related functions
typedef struct wave_struct {
    float time;
    float output;
    float omega;
    float period;
    bool is_playing;
    char adsr_stat; // a, d, s, r, n
    float adsr_multi;
} wave_struct;

wave_struct waves[20] = {
    {0, 0, 2 * M_PI * 261.63, 1 / 261.63, false, 'n', 0}, // C4
    {0, 0, 2 * M_PI * 277.18, 1 / 277.18, false, 'n', 0}, // C#4
    {0, 0, 2 * M_PI * 293.66, 1 / 293.66, false, 'n', 0}, // D4
    {0, 0, 2 * M_PI * 311.13, 1 / 311.13, false, 'n', 0}, // D#4
    {0, 0, 2 * M_PI * 329.63, 1 / 329.63, false, 'n', 0}, // E4
    {0, 0, 2 * M_PI * 349.23, 1 / 349.23, false, 'n', 0}, // F4
    {0, 0, 2 * M_PI * 369.99, 1 / 369.99, false, 'n', 0}, // F#4
    {0, 0, 2 * M_PI * 392.00, 1 / 392.00, false, 'n', 0}, // G4
    {0, 0, 2 * M_PI * 415.30, 1 / 415.30, false, 'n', 0}, // G#4
    {0, 0, 2 * M_PI * 440.00, 1 / 440.00, false, 'n', 0}, // A4
    {0, 0, 2 * M_PI * 466.16, 1 / 466.16, false, 'n', 0}, // A#4
    {0, 0, 2 * M_PI * 493.88, 1 / 493.88, false, 'n', 0}, // B4
    {0, 0, 2 * M_PI * 523.25, 1 / 523.25, false, 'n', 0}, // C5
    {0, 0, 2 * M_PI * 554.37, 1 / 554.37, false, 'n', 0}, // C#5
    {0, 0, 2 * M_PI * 587.33, 1 / 587.33, false, 'n', 0}, // D5
    {0, 0, 2 * M_PI * 622.25, 1 / 622.25, false, 'n', 0}, // D#5
    {0, 0, 2 * M_PI * 659.25, 1 / 659.25, false, 'n', 0}, // E5
    {0, 0, 2 * M_PI * 698.46, 1 / 698.46, false, 'n', 0}, // F5
    {0, 0, 2 * M_PI * 739.99, 1 / 739.99, false, 'n', 0}, // F#5
    {0, 0, 2 * M_PI * 783.99, 1 / 783.99, false, 'n', 0}  // G5
};

bool g_update_canvas = true; // flag to update the canvas

void update_all_waves();
void update_wave(wave_struct *w);
uint32_t get_all_waves_output();
float get_wave_output(wave_struct *w);

#pragma endregion

#pragma region Images

short unsigned int sine[900] = {0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2104, 0x2965, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2965, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2124, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5AEB, 0x39C7, 0x0000, 0x0000, 0x0000, 0x0000, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x1082, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2124, 0x2965, 0x2124, 0x2945, 0x5AEB, 0x5ACB, 0x5AEB, 0x4A69, 0x0000, 0x0000, 0x39C7, 0x52AA, 0x528A, 0x0000, 0x0000, 0x18C3, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5AEB, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x528A, 0x5AEB, 0x5ACB, 0x5ACB, 0x4A69, 0x0000, 0x0000, 0x2965, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x4A49, 0x0000, 0x2124, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x4A49, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x5ACB, 0x5ACB, 0x5AEB, 0x18C3, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5AEB, 0x0000, 0x0000, 0x4208, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x39E7, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x39C7, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x528A, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x0000, 0x4208, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0861, 0x0000, 0x3186, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2965, 0x0000, 0x2945, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5AEB, 0x52AA, 0x0020, 0x0000, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x0861, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x2945, 0x2124, 0x2124, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x52AA, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x52AA, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x528A, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x3186, 0x39C7, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2965, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2965};

void plot_image_sine(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, sine[i * 30 + j]);
        }
    }
}

void erase_image_sine(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, 0);
        }
    }
}

short unsigned int sawtooth[900] = {0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2104, 0x2965, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2965, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2124, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2945, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x0020, 0x0841, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x39E7, 0x0000, 0x0000, 0x0861, 0x5AEB, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x5AEB, 0x52AA, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x1082, 0x0000, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x0000, 0x0000, 0x0861, 0x5ACB, 0x0020, 0x0000, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2965, 0x0000, 0x0000, 0x4228, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x2965, 0x2124, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0020, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0020, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x1082, 0x3186, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x0841, 0x18C3, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x0000, 0x0020, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x39C7, 0x0000, 0x0000, 0x0841, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x5ACB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0841, 0x5ACB, 0x5ACB, 0x4A69, 0x0000, 0x0000, 0x0020, 0x4A49, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x2104, 0x2945, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x0000, 0x0841, 0x5ACB, 0x0020, 0x0000, 0x0000, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x5AEB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x0000, 0x0020, 0x0841, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2965, 0x2945, 0x2124, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2124, 0x2945, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x0000, 0x0000, 0x5ACB, 0x52AA, 0x5ACB, 0x52AA, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x5ACB, 0x52AA, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2965, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2965};

void plot_image_sawtooth(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, sawtooth[i * 30 + j]);
        }
    }
}

void erase_image_sawtooth(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, 0);
        }
    }
}

short unsigned int square[900] = {0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2104, 0x2965, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2965, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2124, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2945, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2124, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x1082, 0x0000, 0x0000, 0x0020, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x2965, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x0020, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x2104, 0x2945, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x0000, 0x0020, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2965, 0x2124, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2965, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2965};

void plot_image_square(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, square[i * 30 + j]);
        }
    }
}

void erase_image_square(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, 0);
        }
    }
}

short unsigned int triangle[900] = {0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2104, 0x2965, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2965, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2124, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x0841, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5AEB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x2124, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0841, 0x0000, 0x10A2, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x0861, 0x0000, 0x0000, 0x0000, 0x4A49, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2945, 0x52AA, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x31A6, 0x0000, 0x0000, 0x18C3, 0x0000, 0x0000, 0x4228, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x4A69, 0x0000, 0x0000, 0x39E7, 0x5AEB, 0x0861, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x52AA, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5AEB, 0x5ACB, 0x0020, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x52AA, 0x5ACB, 0x5AEB, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x2965, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x528A, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x0000, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x0841, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x4A49, 0x4A69, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x0000, 0x0000, 0x31A6, 0x5ACB, 0x5AEB, 0x5ACB, 0x10A2, 0x0000, 0x0000, 0x4A69, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x0000, 0x0000, 0x4A49, 0x5ACB, 0x4208, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5AEB, 0x2104, 0x2124, 0x2945, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x4228, 0x0000, 0x0000, 0x39E7, 0x0000, 0x0000, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x10A2, 0x0020, 0x0000, 0x0000, 0x52AA, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2965, 0x2124, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x0861, 0x0000, 0x2965, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x52AA, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x52AA, 0x5AEB, 0x5AEB, 0x5AEB, 0x52AA, 0x5ACB, 0x5ACB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2124, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2965, 0x2124, 0x5ACB, 0x5ACB, 0x5AEB, 0x5ACB, 0x5AEB, 0x52AA, 0x5AEB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x2945, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2945, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5ACB, 0x5AEB, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2124, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2965, 0x2124, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2965, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2124, 0x2945, 0x2124, 0x2945, 0x2945, 0x2945, 0x2945, 0x2124, 0x2945, 0x2965};

void plot_image_triangle(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, triangle[i * 30 + j]);
        }
    }
}

void erase_image_triangle(int x, int y) {
    for (int i = 0; i < 30; i++) {
        for (int j = 0; j < 30; j++) {
            plot_pixel(x + j, y + i, 0);
        }
    }
}

#pragma endregion

#pragma region Main

int main () {

    audio_s *audio_ptr = (audio_s *)AUDIO_BASE;

    // Setup I/O devices to handle interrupts
    set_key();
    set_ps2();

    // Setup Control Registers to handle interrupts
    int mstatus_value, mtvec_value, mie_value;
    mstatus_value = 0b1000; // interrupt bit mask to disable interrupts
    __asm__ volatile ("csrc mstatus, %0" :: "r"(mstatus_value)); 

    mtvec_value = (int) &handler; // set trap address
    __asm__ volatile ("csrw mtvec, %0" :: "r"(mtvec_value));

    // disable all interrupts that are currently enabled
    __asm__ volatile ("csrr %0, mie" : "=r"(mie_value));
    __asm__ volatile ("csrc mie, %0" :: "r"(mie_value));

    mie_value = 0x40000; // KEY interrupts IRQ14
    //mie_value |= 0x10000; // Timer interrupts IRQ16
    mie_value |= 0x400000; // PS2 interrupts IRQ22
    __asm__ volatile ("csrs mie, %0" :: "r"(mie_value)); // set interrupt enables
    __asm__ volatile ("csrs mstatus, %0" :: "r"(mstatus_value)); // enable Nios V interrupts

    // printf("finished setting up interrupts\n");


    // VGA related codes
    volatile int * pixel_ctrl_ptr = (int *)0xFF203020;
    /* set front pixel buffer to Buffer 1 */
    *(pixel_ctrl_ptr + 1) = (int) &Buffer1; // first store the address in the  back buffer
    /* now, swap the front/back buffers, to set the front buffer location */
    wait_for_vsync();
    /* initialize a pointer to the pixel buffer, used by drawing functions */
    pixel_buffer_start = *pixel_ctrl_ptr;
    init_main_screen(); // pixel_buffer_start points to the pixel buffer

    /* set back pixel buffer to Buffer 2 */
    *(pixel_ctrl_ptr + 1) = (int) &Buffer1;
    pixel_buffer_start = *(pixel_ctrl_ptr + 1); // we draw on the back buffer
    init_main_screen(); // pixel_buffer_start points to the pixel buffer

    // Audio related codes
    audio_ptr->CTRL = 0x8; // clear the output FIFOs
    audio_ptr->CTRL = 0x0; // resume input conversion

    while (1)
    {

        // check and update the audio FIFO
        bool status = audio_ptr->RALC == 0 || audio_ptr->WSLC == 0;
        // while (audio_ptr->RALC == 0 || audio_ptr->WSLC == 0);
        if (!status) {
            // input some random data
            update_all_waves();
            
            // // temporary: print all the notes
            // for (int i=0; i<20; i++) {
            //     note_struct *note_ptr = notes + i;
            //     printf("Note %d: Name=%s, Pressed=%d, PS2 Key=%c, Frequency=%.2f Hz\n", 
            //            i, note_ptr->name, note_ptr->pressed, note_ptr->ps2_key, note_ptr->frequency);
            // }

            // // temporary: print all the waves
            // for (int i=0; i<20; i++) {
            //     wave_struct *wave_ptr = waves + i;
            //     printf("Wave %d: Time=%.2f, Output=%.2f, Omega=%.2f, Period=%.2f, IsPlaying=%d\n", 
            //            i, wave_ptr->time, wave_ptr->output, wave_ptr->omega, wave_ptr->period, wave_ptr->is_playing);
            // }

            uint32_t output = get_all_waves_output();
            audio_ptr->LDATA = (int) output;
            audio_ptr->RDATA = (int) output;
            // printf("output: 0x%X\n", output);
        }
        
        /*if (g_update_canvas) {
            draw_main_screen();
            g_update_canvas = false;
        }*/
        // draw_main_screen();

    }

    return 0;
}

#pragma endregion

#pragma region Interrupts

float sine_wave(float phase) {
    return sin(phase);
}

float square_wave(float phase) {
    return (phase >= M_PI) ? -1 : 1;
}

float triangle_wave(float phase) {
    if (phase < M_PI/2) {
        return 2/M_PI*phase;
    } else if (phase > M_PI*3/2) {
        return 2/M_PI*phase - 4;
    } else {
        return 2 - 2/M_PI*phase;
    }
}

float sawtooth_wave(float phase) {
    return (phase < M_PI) ? phase/M_PI : phase/M_PI - 2;
}

void handler (void){
    // printf("inside handler\n");
    int mcause_value;
    __asm__ volatile ("csrr %0, mcause" : "=r"(mcause_value));
    if (mcause_value == 0x80000012) // KEY port
        key_isr();
    else if (mcause_value == 0x80000016) // PS2
        ps2_isr();
    // else, ignore the trap
    g_update_canvas = true;
}

void set_key() {
    volatile int *KEY_ptr = (int *) KEY_BASE;
    *(KEY_ptr + 3) = 0xF; // clear EdgeCapture register
    *(KEY_ptr + 2) = 0xF; // enable interrupts for all KEYs
}

void set_ps2() {
    
    // printf("inside set ps2\n");
    ps2_port *ps2_ptr = (ps2_port *)PS2_BASE;
    // printf("RI bit after ISR: %d\n", (ps2_ptr->CTRL >> 1) & 1);

    unsigned int data = ps2_ptr->DATA;
    // printf("%d%d\n", (data>>16)&0xFF, data>>24&0xFF);

    
    // printf("%d\n", (data & 0x8000) >> 15);
    while ((data & 0x8000) != 0) {
        data = ps2_ptr->DATA;
        // printf("word removed\n");
    }

    ps2_ptr->CTRL |= 0x1;
    // printf("RI bit after ISR: %d\n", (ps2_ptr->CTRL >> 1) & 1);
}

void key_isr() {
    // printf("inside key isr\n");
    volatile int *key_ptr = (int *) KEY_BASE;
    volatile int *sw_ptr = (int *) SWITCH_BASE;

    int sw_state = *(sw_ptr);
    int key_pressed = *(key_ptr + 3); // read EdgeCapture
    key_pressed &= 0xF;

    // printf("The key pressed is %d\n", key_pressed);

    if ((sw_state & 0x1) == 0x1) {
        // printf("addition mode code goes here\n");
        if (key_pressed == 1) {
            current_waves[SAW_IDX] += 1;
        } else if (key_pressed == 2) {
            current_waves[TRI_IDX] += 1;
        } else if (key_pressed == 4) {
            current_waves[SQR_IDX] += 1;
        } else if (key_pressed == 8) {
            current_waves[SIN_IDX] += 1;
        }
        draw_waveform(90, 80, 140, 70);
    } else if (((sw_state >> 1) & 0x1) == 0x1) {
        // printf("subtraction mode code goes here\n");
        if (key_pressed == 1) {
            current_waves[SAW_IDX] -= 1;
        } else if (key_pressed == 2) {
            current_waves[TRI_IDX] -= 1;
        } else if (key_pressed == 4) {
            current_waves[SQR_IDX] -= 1;
        } else if (key_pressed == 8) {
            current_waves[SIN_IDX] -= 1;
        }
        draw_waveform(90, 80, 140, 70);
    } else if (((sw_state >> 2) & 0x1) == 0x1) {
        // printf("attack\n");
        if (key_pressed == 1) { // toggle rate
            fast_knob_change = !fast_knob_change;
        } else if (key_pressed == 2) { // reset value
            attack_val = 1;
        } else if (key_pressed == 4) { // decrease value
            if (attack_val - (fast_knob_change ? 0.1 : 0.02) >= 0) {
                attack_val -= (fast_knob_change ? 0.1 : 0.02);
            }
        } else if (key_pressed == 8) { // increase value
            if (attack_val + (fast_knob_change ? 0.1 : 0.02) <= 1) {
                attack_val += (fast_knob_change ? 0.1 : 0.02);
            }
        }
        update_adsr('a');
    } else if (((sw_state >> 3) & 0x1) == 0x1) {
        // printf("delay\n");
        if (key_pressed == 1) { // toggle rate
            fast_knob_change = !fast_knob_change;
        } else if (key_pressed == 2) { // reset value
            decay_val = 0.5;
        } else if (key_pressed == 4) { // decrease value
            if (decay_val - (fast_knob_change ? 0.1 : 0.02) >= 0) {
                decay_val -= (fast_knob_change ? 0.1 : 0.02);
            }
        } else if (key_pressed == 8) { // increase value
            if (decay_val + (fast_knob_change ? 0.1 : 0.02) <= 1) {
                decay_val += (fast_knob_change ? 0.1 : 0.02);
            }
        }
        update_adsr('d');
    } else if (((sw_state >> 4) & 0x1) == 0x1) {
        // printf("sustain\n");
        if (key_pressed == 1) { // toggle rate
            fast_knob_change = !fast_knob_change;
        } else if (key_pressed == 2) { // reset value
            sustain_val = 1;
        } else if (key_pressed == 4) { // decrease value
            if (sustain_val - (fast_knob_change ? 0.1 : 0.02) >= 0) {
                sustain_val -= (fast_knob_change ? 0.1 : 0.02);
            }
        } else if (key_pressed == 8) { // increase value
            if (sustain_val + (fast_knob_change ? 0.1 : 0.02) <= 1) {
                sustain_val += (fast_knob_change ? 0.1 : 0.02);
            }
        }
        update_adsr('s');
    } else if (((sw_state >> 5) & 0x1) == 0x1) {
        // printf("release\n");
        if (key_pressed == 1) { // toggle rate
            fast_knob_change = !fast_knob_change;
        } else if (key_pressed == 2) { // reset value
            release_val = 0;
        } else if (key_pressed == 4) { // decrease value
            if (release_val - (fast_knob_change ? 0.1 : 0.02) >= 0) {
                release_val -= (fast_knob_change ? 0.1 : 0.02);
            }
        } else if (key_pressed == 8) { // increase value
            if (release_val + (fast_knob_change ? 0.1 : 0.02) <= 1) {
                release_val += (fast_knob_change ? 0.1 : 0.02);
            }
        }
        update_adsr('r');
    } else {
        // If no specific mode is selected, then the selected waveform overwrites previous
        int probe_key_pressed = 1;
        for (int idx = 0; idx < 4; idx++) {
            // if waveform is selected, reset to 1, else, reset to 0
            current_waves[4-1-idx] = (probe_key_pressed == key_pressed) ? 1 : 0;
            probe_key_pressed *= 2;
        }
        draw_waveform(90, 80, 140, 70);
    }

    for (int i = 0; i < 4; i++) {
        // printf("%d ", current_waves[i]);
    }
    // printf("\n");

    *(key_ptr + 3) = 0xF; // clear EdgeCapture register
}

void ps2_isr() {
    // printf("inside ps2 isr\n");
    ps2_port *ps2_ptr = (ps2_port *)PS2_BASE;

    unsigned int data = ps2_ptr->DATA;
    if ((data & 0x8000) != 0) {
        bool break_code = false;
        uint8_t code = data & 0xFF;
        // printf("Hex: 0x%02X\n", code);

        // Check if break code
        if (code == 0xF0) { 
            data = ps2_ptr->DATA;
            code = data & 0xFF;
            break_code = true;
            // printf("breakcode detected\n");
        }

        for (int idx = 0; idx < 20; idx++) {
            if (code == notes[idx].code) {
                notes[idx].pressed = break_code ? false : true;
                if (waves[idx].is_playing != notes[idx].pressed) {
                    waves[idx].is_playing = notes[idx].pressed;
                    if (waves[idx].is_playing) {
                        waves[idx].adsr_stat = 'a';
                    }
                    update_keybd(idx);
                }
                // printf("note represent by %c is now %d\n", notes[idx].ps2_key, notes[idx].pressed);
            }
        }

    }
    // printf(data);
}

void update_all_waves() {
    for (int i=0; i<20; i++) {
        update_wave(&waves[i]);
    }
}

void update_wave(wave_struct *w) {
    if (!w->is_playing) {
        if (w->adsr_stat == 'n') {
            w->output = 0;
            return;
        } else {
            // calculate envelope multiplier and return
            w->adsr_stat = 'r';
            w->adsr_multi -= sustain_val * (1 - release_val) * (1 - release_val);

            // change state to n if release is done
            if (w->adsr_multi <= 0) {
                w->adsr_multi = 0;
                w->adsr_stat = 'n';
            }
        }
        
    }

    static float dt = 1.0 / 8000.0;
    w->time += dt;
    if (w->time >= w->period) {
        w->time -= w->period;
    }
    float phase = w->time * w->omega;
    
    w->output = 0;
    if (current_waves[0] != 0) {
        w->output += sine_wave(phase) * current_waves[0];
    }
    if (current_waves[1] != 0) {
        w->output += square_wave(phase) * current_waves[1];
    }
    if (current_waves[2] != 0) {
        w->output += triangle_wave(phase) * current_waves[2];
    }
    if (current_waves[3] != 0) {
        w->output += sawtooth_wave(phase) * current_waves[3];
    }

    // Calculating adsr envelope multiplier
    if (w->adsr_stat == 'a') {
        w->adsr_multi += attack_val * attack_val;
        if (w->adsr_multi > 1) {
            w->adsr_multi = 1;
            w->adsr_stat = 'd';
        }
    } else if (w->adsr_stat == 'd') {
        if (decay_val == 0) {
            w->adsr_multi = sustain_val;
            w->adsr_stat = 's';
        } else {
            w->adsr_multi -= sustain_val * (1 - decay_val) * (1 - decay_val);
            if (w->adsr_multi < sustain_val) {
                w->adsr_multi = sustain_val;
                w->adsr_stat = 's';
            }
        }
    } 

    w->output *= w->adsr_multi;
}

uint32_t get_all_waves_output() {
    float temp_output = 0;
    for (int i=0; i<20; i++) {
        temp_output += get_wave_output(&waves[i]);
    }

    uint32_t output = (uint32_t) (temp_output * 0x7FFFFFF + 0x7FFFFFFF);

    return output;
}

float get_wave_output(wave_struct *w) {
    return w->output;
}

#pragma endregion

#pragma region VGA Helper

// VGA related functions
void update_x_y(int* x, int* y, int* last_x, int* last_y, int* last_last_x, int* last_last_y, int* dx, int* dy) {
    *last_last_y = *last_y;
    *last_y = *y;
    if (*y == 239 - 50 || *y == 0) {
        *dy = -*dy;
    }
    *y += *dy;

    *last_last_x = *last_x;
    *last_x = *x;
    if (*x == 319 - 50 || *x == 0) {
        *dx = -*dx;
    }
    *x += *dx;
}

void plot_pixel(int x, int y, short int line_color)
{
    volatile short int *one_pixel_address;
        
        one_pixel_address = (volatile short int *)(pixel_buffer_start + (y << 10) + (x << 1));
        
        *one_pixel_address = line_color;
}

void fill_background() {
    for (int x = 0; x < 320; x++) {
        for (int y = 0; y < 240; y++) {
            plot_pixel(x, y, rgb_to_16bit(40, 40, 40));
        }
    }
}

void draw_line(int x0, int y0, int x1, int y1, short int line_color) {
    bool is_steep = abs(y1 - y0) > abs(x1 - x0);

    if (is_steep) {
        swap(&x0, &y0);
        swap(&x1, &y1);
    }
    if (x0 > x1) {
        swap(&x0, &x1);
        swap(&y0, &y1);
    }

    int deltax = x1 - x0;
    int deltay = abs(y1 - y0);
    int error = -(deltax / 2);
    int y = y0;

    int y_step = 1;
    if (y0 >= y1) {
        y_step = -1;
    }

    for (int x = x0; x <= x1; x++) {
        if (is_steep) {
            plot_pixel(y, x, line_color);
        } else {
            plot_pixel(x, y, line_color);
        }
        error += deltay;
        if (error > 0) {
            y += y_step;
            error -= deltax;
        }
    }
}

void swap(int* x, int* y) {
    int x_value = *x;
    int y_value = *y;

    *x = y_value;
    *y = x_value;
}

void wait_for_vsync() {
    volatile int * pixel_ctrl_ptr = (volatile int *)0xFF203020; // pixel controller
    register int status;

    *pixel_ctrl_ptr = 1; // start the synchronization process

    status = *(pixel_ctrl_ptr + 3);
    while ((status & 0x01) != 0) {
        status = *(pixel_ctrl_ptr + 3);
    }
}

void draw_rect(int x, int y, int width, int height, short int color) {
    // top line
    draw_line(x, y, x + width, y, color);
    // bottom line
    draw_line(x, y + height, x + width, y + height, color);
    // left line
    draw_line(x, y, x, y + height, color);
    // right line
    draw_line(x + width, y, x + width, y + height, color);
}

void fill_rect(rectangle rect, short int color) {   
    for (int dx = 0; dx < rect.width; dx++) {
        for (int dy = 0; dy < rect.height; dy++) {
            plot_pixel(rect.x_base + dx, rect.y_base + dy, color);
        }
    }
}

void fill_rect_noinit(int x_base, int y_base, int width, int height, short int color){
    rectangle temp_rect = {x_base, y_base, width, height};
    fill_rect(temp_rect, color);
}

#pragma endregion

#pragma region Drawing

void draw_wave_selection(int x, int y, int width, int height) {
    draw_rect(x, y, width, height, 0xFFFF);
    plot_image_sine(x + 20, y + 5);
    plot_image_sawtooth(x + 90, y + 5);
    plot_image_square(x + 150, y + 5);
    plot_image_triangle(x + 210, y + 5);
}

void init_wave_data_x() {
    for (int i = 0; i < 140; i++) {
        wave_data_x[i] = i * 2 * 3.1415926 / 140;
    }
}

void update_wave_data_y() {

    for (int i = 0; i < 140; i++) {
        float phase = wave_data_x[i];
        wave_data_y[i] = 0;

        if (current_waves[0] != 0) {
            wave_data_y[i] += sine_wave(phase) * current_waves[0];
        }
        if (current_waves[1] != 0) {
            wave_data_y[i] += square_wave(phase) * current_waves[1];
        }
        if (current_waves[2] != 0) {
            wave_data_y[i] += triangle_wave(phase) * current_waves[2];
        }
        if (current_waves[3] != 0) {
            wave_data_y[i] += sawtooth_wave(phase) * current_waves[3];
        }

        int num_waves = 0;
        for (int i = 0; i < 4; i++) {
            num_waves += fabs(current_waves[i]);
        }

        wave_data_y[i] *= (25 / num_waves);
        wave_data_y[i] += 35;
        wave_data_plot_y[i] = (int) wave_data_y[i];
    }
}

void draw_waveform(int x, int y, int width, int height) {
    fill_rect_noinit(x, y, width, height, rgb_to_16bit(0, 0, 0));
    init_wave_data_x();
    update_wave_data_y();
    for (int i = 1; i < 140; i++) {
        draw_line(x + i - 1, y + wave_data_plot_y[i - 1], x + i, y + wave_data_plot_y[i], rgb_to_16bit(255, 182, 80));
    }
}

void draw_keybd() {
    //fill_rect(x, y, width, height, 0xFFFF);
    for (int note_idx = 0; note_idx < 20; note_idx++) {
        for (int rect_idx = 0; rect_idx < notes[note_idx].num_rects; rect_idx++) {
            if (notes[note_idx].pressed) {
                fill_rect(notes[note_idx].rectangles[rect_idx], rgb_to_16bit(255, 182, 80));
            } else {
                fill_rect(notes[note_idx].rectangles[rect_idx], (notes[note_idx].num_rects == 1) ? rgb_to_16bit(0, 0, 0) : rgb_to_16bit(255, 255, 255));
            }
        }
    }
}

void update_keybd(int note_idx) {
    for (int rect_idx = 0; rect_idx < notes[note_idx].num_rects; rect_idx++) {
        if (notes[note_idx].pressed) {
            fill_rect(notes[note_idx].rectangles[rect_idx], rgb_to_16bit(255, 182, 80));
        } else {
            fill_rect(notes[note_idx].rectangles[rect_idx], (notes[note_idx].num_rects == 1) ? rgb_to_16bit(0, 0, 0) : rgb_to_16bit(255, 255, 255));
        }
    }
}

void draw_adsr() {
    const int shadow_disp = 5;
    const int knob_min = 145;
    const int knob_len = 70;

    // Drawing bases
    fill_rect_noinit(46, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Attack
    fill_rect_noinit(66, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Delay
    fill_rect_noinit(246, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Sustain
    fill_rect_noinit(266, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Release

    // Drawing knobs
    int a_knob_pos = knob_min - attack_val*(knob_len);
    fill_rect_noinit(45, a_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // A shadow
    fill_rect_noinit(45, a_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // A knob
    int d_knob_pos = knob_min - decay_val*(knob_len);
    fill_rect_noinit(65, d_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // D shadow
    fill_rect_noinit(65, d_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // D knob
    int s_knob_pos = knob_min - sustain_val*(knob_len);
    fill_rect_noinit(245, s_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // S shadow
    fill_rect_noinit(245, s_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // S knob
    int r_knob_pos = knob_min - release_val*(knob_len);
    fill_rect_noinit(265, r_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // R shadow
    fill_rect_noinit(265, r_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // R knob
}

void update_adsr(char changed) {
    const int shadow_disp = 5;
    const int knob_min = 145;
    const int knob_len = 70;

    if (changed == 'a') {
        // erase
        fill_rect_noinit(46, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Attack
        fill_rect_noinit(45, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Left Border
        fill_rect_noinit(55, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Right Border

        // drawing knob
        int a_knob_pos = knob_min - attack_val*(knob_len);
        fill_rect_noinit(45, a_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // A shadow
        fill_rect_noinit(45, a_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // A knob
    } else if (changed == 'd') {
        // erase
        fill_rect_noinit(66, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Delay
        fill_rect_noinit(65, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Left Border
        fill_rect_noinit(75, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Right Border

        // drawing knob
        int d_knob_pos = knob_min - decay_val*(knob_len);
        fill_rect_noinit(65, d_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // D shadow
        fill_rect_noinit(65, d_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // D knob
    } else if (changed == 's') {
        // erase
        fill_rect_noinit(246, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Sustain
        fill_rect_noinit(245, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Left Border
        fill_rect_noinit(255, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Right Border

        // drawing knob
        int s_knob_pos = knob_min - sustain_val*(knob_len);
        fill_rect_noinit(245, s_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // S shadow
        fill_rect_noinit(245, s_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // S knob
    } else if (changed == 'r') {
        // erase
        fill_rect_noinit(266, 75, 8, 75, rgb_to_16bit(0, 0, 0)); // Release
        fill_rect_noinit(265, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Left Border
        fill_rect_noinit(275, 75, 1, 75, rgb_to_16bit(40, 40, 40)); // Right Border

        // drawing knob
        int r_knob_pos = knob_min - release_val*(knob_len);
        fill_rect_noinit(265, r_knob_pos + shadow_disp, 10, 2, rgb_to_16bit(60, 60, 60)); // R shadow
        fill_rect_noinit(265, r_knob_pos, 10, 5, rgb_to_16bit(90, 90, 90)); // R knob
    }
}

void draw_main_screen() {
    fill_background();
    draw_wave_selection(30, 20, 260, 40);
    draw_waveform(90, 80, 140, 70);
    draw_keybd();
    draw_adsr();
}

void init_main_screen() {
    fill_background();
    draw_wave_selection(30, 20, 260, 40);
    draw_waveform(90, 80, 140, 70);
    draw_keybd();
    draw_adsr();
}

short int rgb_to_16bit(int r, int g, int b) {
    short int short_r = r * 31 / 255;
    short int short_g = g * 63 / 255;
    short int short_b = b * 31 / 255;

    return (short_r << 11) + (short_g << 5) + short_b;
}

#pragma endregion